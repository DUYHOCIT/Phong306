<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr√¨nh xem GLB - Unreal Style Pro</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Arial, sans-serif; }
        canvas { display: block; }
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            cursor: pointer;
            text-align: center;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #ffffff;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            font-size: 14px;
            line-height: 1.5;
        }
        .key { font-weight: bold; color: #ffff00; background: #333; padding: 2px 5px; border-radius: 3px; }
        #speed-bar {
            margin-top: 5px;
            font-weight: bold;
            color: #00ff00;
        }
    </style>
</head>
<body>
    <div id="overlay">
        <h1>CLICK ƒê·ªÇ B·∫ÆT ƒê·∫¶U</h1>
        <p>W/S: Bay t·ªõi/lui (theo h∆∞·ªõng nh√¨n)</p>
        <p>A/D: Sang ngang | E/Q: L√™n/Xu·ªëng (Th·∫≥ng ƒë·ª©ng)</p>
        <p>üñ±Ô∏è LƒÉn chu·ªôt: Ch·ªânh t·ªëc ƒë·ªô bay</p>
        <p style="color: #aaa; margin-top: 20px;">(B·∫•m ESC ƒë·ªÉ hi·ªán chu·ªôt)</p>
    </div>

    <div id="info">
        <span class="key">W/S</span> Ti·∫øn/L√πi | 
        <span class="key">A/D</span> Tr√°i/Ph·∫£i | 
        <span class="key">E</span> L√™n | 
        <span class="key">Q</span> Xu·ªëng
        <br>
        <div id="speed-bar">T·ªëc ƒë·ªô bay: 15.0</div>
        <span id="status" style="color: #ccc; font-size: 12px;">ƒêang t·∫£i...</span>
    </div>

    <canvas id="webgl-canvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- C·∫§U H√åNH ---
        let flySpeed = 15.0; // T·ªëc ƒë·ªô c∆° b·∫£n
        const MIN_SPEED = 1.0;
        const MAX_SPEED = 100.0;
        
        // --- 1. SETUP SCENE ---
        const canvas = document.getElementById('webgl-canvas');
        const overlay = document.getElementById('overlay');
        const statusEl = document.getElementById('status');
        const speedEl = document.getElementById('speed-bar');
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        scene.fog = new THREE.Fog(0x222222, 20, 200);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;

        // --- 2. √ÅNH S√ÅNG & M√îI TR∆Ø·ªúNG ---
        const gridHelper = new THREE.GridHelper(200, 200, 0x444444, 0x333333);
        scene.add(gridHelper);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(10, 30, 20);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- 3. ƒêI·ªÄU KHI·ªÇN & S·ª∞ KI·ªÜN ---
        const controls = new PointerLockControls(camera, document.body);

        // Click ƒë·ªÉ b·∫Øt ƒë·∫ßu
        overlay.addEventListener('click', () => controls.lock());
        controls.addEventListener('lock', () => overlay.style.display = 'none');
        controls.addEventListener('unlock', () => overlay.style.display = 'flex');

        // X·ª≠ l√Ω lƒÉn chu·ªôt ƒë·ªÉ ch·ªânh t·ªëc ƒë·ªô
        document.addEventListener('wheel', (event) => {
            if (controls.isLocked) {
                // LƒÉn l√™n (deltaY < 0) -> TƒÉng t·ªëc
                // LƒÉn xu·ªëng (deltaY > 0) -> Gi·∫£m t·ªëc
                const zoomFactor = 1.1; // M·ªói n·∫•c tƒÉng/gi·∫£m 10%
                
                if (event.deltaY < 0) {
                    flySpeed *= zoomFactor;
                } else {
                    flySpeed /= zoomFactor;
                }

                // Gi·ªõi h·∫°n t·ªëc ƒë·ªô
                flySpeed = Math.max(MIN_SPEED, Math.min(flySpeed, MAX_SPEED));
                
                // Hi·ªÉn th·ªã ra m√†n h√¨nh (l√†m tr√≤n 1 s·ªë l·∫ª)
                speedEl.innerText = `T·ªëc ƒë·ªô bay: ${flySpeed.toFixed(1)}`;
            }
        });

        // X·ª≠ l√Ω ph√≠m b·∫•m
        const moveState = {
            forward: false, backward: false,
            left: false, right: false,
            up: false, down: false,
            sprint: false
        };

        const onKeyDown = (e) => {
            switch (e.code) {
                case 'KeyW': moveState.forward = true; break;
                case 'KeyS': moveState.backward = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyD': moveState.right = true; break;
                case 'KeyE': moveState.up = true; break; // L√™n
                case 'KeyQ': moveState.down = true; break; // Xu·ªëng
                case 'ShiftLeft': moveState.sprint = true; break;
            }
        };

        const onKeyUp = (e) => {
            switch (e.code) {
                case 'KeyW': moveState.forward = false; break;
                case 'KeyS': moveState.backward = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyD': moveState.right = false; break;
                case 'KeyE': moveState.up = false; break;
                case 'KeyQ': moveState.down = false; break;
                case 'ShiftLeft': moveState.sprint = false; break;
            }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        // --- 4. T·∫¢I M√î H√åNH ---
        const loader = new GLTFLoader();
        const modelURL = "https://cdn.jsdelivr.net/gh/DUYHOCIT/Phong302@main/phong302.glb";

        loader.load(modelURL, (gltf) => {
            const object = gltf.scene;
            
            // B·∫≠t b√≥ng ƒë·ªï cho t·∫•t c·∫£ mesh
            object.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            // Auto-center v√† ƒë·∫∑t l√™n m·∫∑t s√†n
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            object.position.sub(center);
            object.position.y += size.y / 2;
            scene.add(object);

            // ƒê·∫∑t camera l√πi ra xa
            const maxDim = Math.max(size.x, size.y, size.z);
            camera.position.set(0, maxDim * 0.5, maxDim * 1.5);
            camera.lookAt(0, 0, 0);

            statusEl.innerText = "ƒê√£ t·∫£i xong!";
        }, undefined, (err) => {
            console.error(err);
            statusEl.innerText = "L·ªói t·∫£i file!";
        });

        // --- 5. LOGIC CHUY·ªÇN ƒê·ªòNG (PHYSICS) ---
        const clock = new THREE.Clock();
        const velocity = new THREE.Vector3(); // V·∫≠n t·ªëc qu√°n t√≠nh

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (controls.isLocked) {
                // T√≠nh to√°n t·ªëc ƒë·ªô th·ª±c t·∫ø (Shift ƒë·ªÉ nh√¢n 2.5 l·∫ßn t·ªëc ƒë·ªô hi·ªán t·∫°i)
                const actualSpeed = moveState.sprint ? flySpeed * 2.5 : flySpeed;
                
                // 1. Ma s√°t (Gi·∫£m t·ªëc t·ª´ t·ª´ khi nh·∫£ ph√≠m)
                const damping = 10.0;
                velocity.x -= velocity.x * damping * delta; // Tr·ª•c ngang
                velocity.z -= velocity.z * damping * delta; // Tr·ª•c h∆∞·ªõng nh√¨n
                velocity.y -= velocity.y * damping * delta; // Tr·ª•c l√™n xu·ªëng

                // 2. T√≠nh l·ª±c ƒë·∫©y t·ª´ ph√≠m
                // W/S: H∆∞·ªõng nh√¨n (Z)
                if (moveState.forward) velocity.z -= actualSpeed * delta;
                if (moveState.backward) velocity.z += actualSpeed * delta;

                // A/D: Sang ngang (X)
                if (moveState.left) velocity.x -= actualSpeed * delta;
                if (moveState.right) velocity.x += actualSpeed * delta;

                // E/Q: L√™n xu·ªëng (Y)
                if (moveState.up) velocity.y += actualSpeed * delta;
                if (moveState.down) velocity.y -= actualSpeed * delta;

                // 3. √Åp d·ª•ng chuy·ªÉn ƒë·ªông
                // translateZ/X: Di chuy·ªÉn t∆∞∆°ng ƒë·ªëi theo h∆∞·ªõng Camera quay
                camera.translateZ(velocity.z * delta);
                camera.translateX(velocity.x * delta);
                
                // position.y: Di chuy·ªÉn tuy·ªát ƒë·ªëi theo tr·ª•c th·∫≥ng ƒë·ª©ng (Thang m√°y)
                camera.position.y += velocity.y * delta;
            }

            renderer.render(scene, camera);
        }

        // Resize c·ª≠a s·ªï
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
