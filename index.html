<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phòng của tôi :))</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
            cursor: pointer;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #ffffff;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
        .key { font-weight: bold; color: #ffff00; }
    </style>
</head>
<body>
    <div id="overlay">
        <h1>CLICK CHUỘT ĐỂ BẮT ĐẦU</h1>
        <p>(ESC để thoát chuột)</p>
    </div>

    <div id="info">
        <span class="key">W/A/S/D</span>: Di chuyển | 
        <span class="key">E</span>: Lên | 
        <span class="key">Q</span>: Xuống | 
        <span class="key">Shift</span>: Chạy nhanh
        <br>
        <span id="status">Đang tải...</span>
    </div>

    <canvas id="webgl-canvas"></canvas>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // 1. CẤU HÌNH CƠ BẢN
        const canvas = document.getElementById('webgl-canvas');
        const overlay = document.getElementById('overlay');
        const statusEl = document.getElementById('status');
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222); // Màu nền xám đậm kiểu Blender
        scene.fog = new THREE.Fog(0x222222, 10, 100); // Thêm sương mù cho chiều sâu

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 5); // Vị trí mặc định

        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true; // Bật bóng đổ cho đẹp

        // 2. ÁNH SÁNG & LƯỚI (KIỂU BLENDER)
        // Lưới vô tận (giả lập bằng lưới to)
        const gridHelper = new THREE.GridHelper(200, 200, 0x444444, 0x333333);
        scene.add(gridHelper);

        // Ánh sáng môi trường
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        // Ánh sáng mặt trời (có bóng)
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // 3. ĐIỀU KHIỂN FPS (POINTER LOCK)
        const controls = new PointerLockControls(camera, document.body);

        // Xử lý ẩn/hiện menu khi click
        overlay.addEventListener('click', () => {
            controls.lock();
        });

        controls.addEventListener('lock', () => {
            overlay.style.display = 'none';
        });

        controls.addEventListener('unlock', () => {
            overlay.style.display = 'flex';
        });

        // 4. XỬ LÝ DI CHUYỂN (WASD + QE)
        const moveState = {
            forward: false, backward: false,
            left: false, right: false,
            up: false, down: false,
            sprint: false
        };

        const onKeyDown = (event) => {
            switch (event.code) {
                case 'KeyW': moveState.forward = true; break;
                case 'KeyS': moveState.backward = true; break;
                case 'KeyA': moveState.left = true; break;
                case 'KeyD': moveState.right = true; break;
                case 'KeyE': moveState.up = true; break;
                case 'KeyQ': moveState.down = true; break;
                case 'ShiftLeft': moveState.sprint = true; break;
            }
        };

        const onKeyUp = (event) => {
            switch (event.code) {
                case 'KeyW': moveState.forward = false; break;
                case 'KeyS': moveState.backward = false; break;
                case 'KeyA': moveState.left = false; break;
                case 'KeyD': moveState.right = false; break;
                case 'KeyE': moveState.up = false; break;
                case 'KeyQ': moveState.down = false; break;
                case 'ShiftLeft': moveState.sprint = false; break;
            }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        // 5. TẢI MÔ HÌNH GLB
        const loader = new GLTFLoader();
        const modelURL = "https://cdn.jsdelivr.net/gh/DUYHOCIT/Phong302@main/phong302.glb";

        statusEl.innerText = "Đang tải mô hình...";

        loader.load(modelURL, (gltf) => {
            const object = gltf.scene;

            // Xử lý đổ bóng cho mô hình
            object.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            // Tự động căn giữa mô hình
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            
            // Đưa mô hình về gốc tọa độ
            object.position.sub(center); 
            // Nâng mô hình lên mặt lưới (nếu đáy nằm dưới đất)
            object.position.y += size.y / 2;

            scene.add(object);

            // Đặt Camera lùi ra xa dựa trên kích thước mô hình để chắc chắn nhìn thấy
            const maxDim = Math.max(size.x, size.y, size.z);
            camera.position.set(0, maxDim * 0.5, maxDim * 1.5);
            camera.lookAt(0, 0, 0);

            statusEl.innerText = "Tải xong! Click màn hình để xem.";
            console.log("Model loaded", size);

        }, (xhr) => {
            const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
            statusEl.innerText = `Đang tải... ${percent}%`;
        }, (error) => {
            console.error(error);
            statusEl.innerText = "Lỗi tải file! Kiểm tra link hoặc Console.";
        });

        // 6. VÒNG LẶP ANIMATION (Xử lý vật lý di chuyển)
        const clock = new THREE.Clock();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (controls.isLocked) {
                // Tốc độ di chuyển
                const actualSpeed = moveState.sprint ? 20.0 : 8.0; 
                // Ma sát (để dừng lại từ từ)
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= velocity.y * 10.0 * delta;

                direction.z = Number(moveState.forward) - Number(moveState.backward);
                direction.x = Number(moveState.right) - Number(moveState.left);
                direction.y = Number(moveState.up) - Number(moveState.down);

                direction.normalize(); // Đảm bảo đi chéo không nhanh hơn đi thẳng

                if (moveState.forward || moveState.backward) velocity.z -= direction.z * actualSpeed * 10.0 * delta;
                if (moveState.left || moveState.right) velocity.x -= direction.x * actualSpeed * 10.0 * delta;
                if (moveState.up || moveState.down) velocity.y -= direction.y * actualSpeed * 10.0 * delta;

                // Di chuyển Camera
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                // Xử lý bay lên/xuống (PointerLock không hỗ trợ native nên phải chỉnh position)
                camera.position.y += velocity.y * delta;
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
